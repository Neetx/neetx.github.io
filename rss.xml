<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Neetx website</title><link>https://neetx.github.io/</link><description>This is a collection of my studies and experiments</description><atom:link href="https://neetx.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2021 &lt;a href="mailto:neetx@protonmail.com"&gt;Neetx&lt;/a&gt; </copyright><lastBuildDate>Fri, 05 Mar 2021 12:22:55 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Windows ASM hello world</title><link>https://neetx.github.io/posts/windows-asm-hello-world/</link><dc:creator>Neetx</dc:creator><description>&lt;div&gt;&lt;p&gt;I have several notes about exploit development in linux system but today
I decided to start some test in windows OS, so like the first time on 
linux I tried to study shellcoding.
After some minutes I figured out that I missed a step: simple assembly and
calling conventions exploration.
So these are my first tests with code and tools &lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;With C function calls&lt;/h3&gt;
&lt;h4&gt;Solution 1 (nasm + gcc)&lt;/h4&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rel&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"Hello world!"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xa&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;text&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;global&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ExitProcess&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nl"&gt;main&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rbp&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rbp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rsp&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rsp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;lea&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rcx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;call&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;xor&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;call&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ExitProcess&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Assembling:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;C:\Users\nobody\Desktop\assembly&amp;gt;nasm -f win64 hello.asm -o hello.obj&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Linking:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;C:\Users\nobody\Desktop\assembly&amp;gt;gcc -o hello.exe hello.obj&lt;/span&gt;

&lt;span class="go"&gt;C:\Users\nobody\Desktop\assembly&amp;gt;hello.exe&lt;/span&gt;
&lt;span class="go"&gt;Hello world!&lt;/span&gt;
&lt;/pre&gt;
&lt;hr&gt;
&lt;h4&gt;Solution 2 (nasm + link)&lt;/h4&gt;
&lt;p&gt;Thanks to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/64413414/unresolved-external-symbol-printf-in-windows-x64-assembly-programming-with-nasm"&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/cpp/porting/visual-cpp-change-history-2003-2015"&gt;microsoft docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;"The definitions of all of the printf and scanf functions have been moved
inline into &lt;stdio.h&gt;, &lt;conio.h&gt;, and other CRT headers. This breaking 
change leads to a linker error (LNK2019, unresolved external symbol) for
any programs that declared these functions locally without including the 
appropriate CRT headers.If possible, you should update the code to include
the CRT headers (that is, add #include &lt;stdio.h&gt;) and the inline functions,
but if you do not want to modify your code to include these header files, 
an alternative solution is to add an additional library to your linker
input, legacy_stdio_definitions.lib."&lt;/stdio.h&gt;&lt;/conio.h&gt;&lt;/stdio.h&gt;&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rel&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"Hello world!"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0xa&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;segment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;text&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;global&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ExitProcess&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_CRT_INIT&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="nl"&gt;main&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rbp&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rbp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rsp&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rsp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;call&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_CRT_INIT&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;CRT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initialization&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;lea&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rcx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;call&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;xor&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;call&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ExitProcess&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Assembling: &lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;C:\Users\nobody\Desktop\assembly&amp;gt;nasm -fwin64  hello.asm -o hello.obj &lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Linking:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;C:\Users\nobody\Desktop\assembly&amp;gt;link hello2.obj /subsystem:console /entry:main /out:hello2.exe kernel32.lib legacy_stdio_definitions.lib  msvcrt.lib&lt;/span&gt;
&lt;/pre&gt;
&lt;hr&gt;
&lt;h3&gt;With Win32API calls&lt;/h3&gt;
&lt;p&gt;32-bit windows api uses stdcall calling convention, so the parameters are
passed on the stack from right to left and the return value is stored into
eax register.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;   &lt;span class="n"&gt;global&lt;/span&gt;  &lt;span class="n"&gt;go&lt;/span&gt;

        &lt;span class="k"&gt;extern&lt;/span&gt;  &lt;span class="n"&gt;_ExitProcess&lt;/span&gt;&lt;span class="mi"&gt;@4&lt;/span&gt;
        &lt;span class="k"&gt;extern&lt;/span&gt;  &lt;span class="n"&gt;_GetStdHandle&lt;/span&gt;&lt;span class="mi"&gt;@4&lt;/span&gt;
        &lt;span class="k"&gt;extern&lt;/span&gt;  &lt;span class="n"&gt;_WriteConsoleA&lt;/span&gt;&lt;span class="mi"&gt;@20&lt;/span&gt;

        &lt;span class="n"&gt;section&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;
&lt;span class="nl"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;db&lt;/span&gt;      &lt;span class="s"&gt;"Hello, World"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="nl"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;db&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nl"&gt;written&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;db&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;

        &lt;span class="n"&gt;section&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;
&lt;span class="nl"&gt;go&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GetStdHandle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;-11&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;push&lt;/span&gt;    &lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="mi"&gt;-11&lt;/span&gt;
        &lt;span class="n"&gt;call&lt;/span&gt;    &lt;span class="n"&gt;_GetStdHandle&lt;/span&gt;&lt;span class="mi"&gt;@4&lt;/span&gt;
        &lt;span class="n"&gt;mov&lt;/span&gt;     &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;eax&lt;/span&gt;

        &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;WriteConsole&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;written&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;push&lt;/span&gt;    &lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="n"&gt;push&lt;/span&gt;    &lt;span class="n"&gt;written&lt;/span&gt;
        &lt;span class="n"&gt;push&lt;/span&gt;    &lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;
        &lt;span class="n"&gt;push&lt;/span&gt;    &lt;span class="n"&gt;msg&lt;/span&gt;
        &lt;span class="n"&gt;push&lt;/span&gt;    &lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;call&lt;/span&gt;    &lt;span class="n"&gt;_WriteConsoleA&lt;/span&gt;&lt;span class="mi"&gt;@20&lt;/span&gt;

        &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;ExitProcess&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;push&lt;/span&gt;    &lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="n"&gt;call&lt;/span&gt;    &lt;span class="n"&gt;_ExitProcess&lt;/span&gt;&lt;span class="mi"&gt;@4&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Assembling:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;C:\Users\nobody\Desktop\assembly&amp;gt;nasm -fwin32 -o hello_win32.obj hello_win32.asm&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Linking:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;C:\Users\nobody\Desktop\assembly&amp;gt;link  hello_win32.obj "C:\Program Files (x86)\Windows Kits\10\lib\10.0.18362.0\um\x86\kernel32.lib" /subsystem:console /entry:go /machine:x86&lt;/span&gt;
&lt;/pre&gt;
&lt;hr&gt;
&lt;h3&gt;With win64API calls&lt;/h3&gt;
&lt;p&gt;64-bit windows api uses fastcall calling convention, so the first four
parameters are passed left to right into:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;rcx&lt;/li&gt;
&lt;li&gt;rdx&lt;/li&gt;
&lt;li&gt;r8&lt;/li&gt;
&lt;li&gt;r9&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The caller must reserve space on the stack even for these parameters, and
the stack must be aligned&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="k"&gt;global&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GetStdHandle&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WriteFile&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;section&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;text&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nl"&gt;main&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rcx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;fffffff5h&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;call&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;GetStdHandle&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rcx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rax&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rdx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NtlpBuffer&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;r8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NtnNBytesToWrite&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;r9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NtlpNBytesWritten&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rsp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mov&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;dword&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;rsp + 32&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;call&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;WriteFile&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;add&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;rsp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nl"&gt;ExitProgram&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;xor&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;section&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;data&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nl"&gt;NtlpBuffer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="s1"&gt;'Hello, World!'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nl"&gt;NtnNBytesToWrite&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;dq&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;eh&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;section&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bss&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nl"&gt;NtlpNBytesWritten&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resd&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;01&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Assembling:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;C:\Users\nobody\Desktop\assembly&amp;gt;nasm -f win64 test.asm&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Linking:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;C:\Users\nobody\Desktop\assembly&amp;gt;gcc -s -o test.exe test.obj&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;or linking with:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="go"&gt;C:\Users\nobody\Desktop\assembly&amp;gt;link hello_win64.obj "C:\Program Files (x86)\Windows Kits\10\lib\10.0.18362.0\um\x64\kernel32.lib"  /subsystem:console /entry:main /LARGEADDRESSAWARE:NO /out:test.exe&lt;/span&gt;
&lt;/pre&gt;
&lt;hr&gt;
&lt;h3&gt;Tools&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;link and gcc are included into VS C/C++ toolchain&lt;/li&gt;
&lt;li&gt;[nasm] (https://nasm.us)&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>#assembler #linker</category><category>#assembly</category><category>#win32api</category><category>#win64api</category><category>#windows</category><guid>https://neetx.github.io/posts/windows-asm-hello-world/</guid><pubDate>Fri, 22 Jan 2021 21:35:07 GMT</pubDate></item><item><title>ELF symbols</title><link>https://neetx.github.io/posts/ELF-symbols/</link><dc:creator>Neetx</dc:creator><description>&lt;div&gt;&lt;p&gt;Function and variable names are called symbols, they must be translated 
into offsets and addresses at compilation time.
The compiler exports &lt;strong&gt;symbolic information&lt;/strong&gt; into the output object, that
holds symbols and interfaces to them (local, external).&lt;/p&gt;
&lt;p&gt;Linkers and debuggers works with symbols accessing the interfaces and the
Symbol Table.
Debugging is possible, but harder, without symbols, as in a stripped elf.
It's possible to remove symbol tables or its entries&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;ELF symbol&lt;/h3&gt;
&lt;p&gt;In an ELF file there is a Symbol Table (max two) as an array of structures
called Elf32_Sym or Elf64_Sym&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="cm"&gt;/* Symbol table entry.  */&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;      &lt;span class="n"&gt;st_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Symbol name (string tbl index) */&lt;/span&gt;
    &lt;span class="n"&gt;Elf32_Addr&lt;/span&gt;      &lt;span class="n"&gt;st_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="cm"&gt;/* Symbol value                   */&lt;/span&gt;
    &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;      &lt;span class="n"&gt;st_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Symbol size                    */&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;   &lt;span class="n"&gt;st_info&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Symbol type and binding        */&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;   &lt;span class="n"&gt;st_other&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="cm"&gt;/* Symbol visibility              */&lt;/span&gt;
    &lt;span class="n"&gt;Elf32_Section&lt;/span&gt;   &lt;span class="n"&gt;st_shndx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="cm"&gt;/* Section index                  */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;Elf32_Sym&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Elf64_Word&lt;/span&gt;     &lt;span class="n"&gt;st_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="cm"&gt;/* Symbol name (string tbl index) */&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;  &lt;span class="n"&gt;st_info&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="cm"&gt;/* Symbol type and binding        */&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;  &lt;span class="n"&gt;st_other&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Symbol visibility              */&lt;/span&gt;
    &lt;span class="n"&gt;Elf64_Section&lt;/span&gt;  &lt;span class="n"&gt;st_shndx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Section index                  */&lt;/span&gt;
    &lt;span class="n"&gt;Elf64_Addr&lt;/span&gt;     &lt;span class="n"&gt;st_value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Symbol value                   */&lt;/span&gt;
    &lt;span class="n"&gt;Elf64_Xword&lt;/span&gt;    &lt;span class="n"&gt;st_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="cm"&gt;/* Symbol size                    */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;Elf64_Sym&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;
&lt;hr&gt;
&lt;h4&gt;st_name&lt;/h4&gt;
&lt;p&gt;If &lt;strong&gt;st_name&lt;/strong&gt; isn't unitialized the the symbol hasn't a name.&lt;/p&gt;
&lt;h4&gt;st_info&lt;/h4&gt;
&lt;p&gt;In &lt;strong&gt;st_info&lt;/strong&gt; there are binding attributes (linkage visibility and
behavior when the symbol is externally referenced)
Common binding:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STB_LOCAL : invisible from outside&lt;/li&gt;
&lt;li&gt;STB_GLOBAL: visible from outside&lt;/li&gt;
&lt;li&gt;STB_WEAK  : global symbol but it can be redefined&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Common types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STT_NOTYPE : type not specified&lt;/li&gt;
&lt;li&gt;STT_OBJECT : symbol is a data object (variable).&lt;/li&gt;
&lt;li&gt;STT_FUNC   : symbol is a code object (function).&lt;/li&gt;
&lt;li&gt;STT_SECTION: symbol is a section.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To get these fields a set of bitmasks are used&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ELF64_ST_BIND(info) ((info) &amp;gt;&amp;gt; 4 )&lt;/li&gt;
&lt;li&gt;ELF64_ST_TYPE(info) ((info) &amp;amp; 0xf)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;st_other&lt;/h4&gt;
&lt;p&gt;Information about symbol visibility, how a symbol can be accessed after it
become part of an object:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STV_DEFAULT  : default visibility, it is equal to symbolâs binding type&lt;/li&gt;
&lt;li&gt;STV_PROTECTED: it is visible by other objects, but cannot be preempted&lt;/li&gt;
&lt;li&gt;STV_HIDDEN   : invisible&lt;/li&gt;
&lt;li&gt;STV_INTERNAL : internal visiblity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Symbol binding&lt;/strong&gt; refers to an external object referencing a symbol at
linking time
&lt;strong&gt;Symbol visibility&lt;/strong&gt; refers on the original object and to an external
object referencing the symbol of interest, at runtime&lt;/p&gt;
&lt;p&gt;Macro to get visibility information: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ELF64_ST_VISIBLITY(o) ((o) &amp;amp; 0x3)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;st_shndx&lt;/h4&gt;
&lt;p&gt;Every symbol is associated with a section, &lt;strong&gt;st_shndx&lt;/strong&gt; contains its index
in the Section Header Table&lt;/p&gt;
&lt;p&gt;Common section type:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SHT_UNDEF: section is not present in the object. The symbol is imported&lt;/li&gt;
&lt;li&gt;SHT_PROGBITS: section is defined in current object&lt;/li&gt;
&lt;li&gt;SHT_SYMTAB, SHT_DYNSYM: Symbol Table (.symtab, .dynsym)&lt;/li&gt;
&lt;li&gt;SHT_STRTAB, SHT_DYNSTR:  String Table (.strtab, .dynstr)&lt;/li&gt;
&lt;li&gt;SHT_REL: Relocation Table without explicit addends (.rel.dyn, .rel.plt)&lt;/li&gt;
&lt;li&gt;SHT_RELA: Relocation Table with explicit addends (.rela.dyn, .rela.plt)&lt;/li&gt;
&lt;li&gt;SHT_HASH: Hash Table for dynamic symbol resolution (.gnu.hash)&lt;/li&gt;
&lt;li&gt;SHT_DYNAMIC: section holding Dynamic Linking information (.dynamic)&lt;/li&gt;
&lt;li&gt;SHT_NOBITS: section takes no space in disk (.bss)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;st_value&lt;/h4&gt;
&lt;p&gt;Symbol value for an entry&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For ET_REL files this value represents a section offset &lt;/li&gt;
&lt;li&gt;For ET_EXEC or ET_DYN files this value represents a virtual address
  If it is equal to 0 and the section pointed by st_shndx has a sh_type
  equal to SHT_UNDEF, then this symbol is imported (so its value is
  resolved at runtime by RTLD(ld.so))&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;st_size&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;st_size&lt;/strong&gt; contains symbol's size&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;String Table&lt;/h3&gt;
&lt;p&gt;In an ELF are commont two Symbol Tables: .symtab and .dynsym.
The .symtab is the global Symbol Table of the object, it has a Sting Table
called .strtab (they have the same number of entries).&lt;/p&gt;
&lt;p&gt;The .dynsym Symbol Table contains symbols for Dynamic Linking, its strings
are in the .dynstr String Table&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;A &lt;strong&gt;stripped&lt;/strong&gt; binary hasn't .symtab and .strtab, so reversing and
debugging is harder, but some symbol can be retrieved by the .dynsym
located at DT_SYMTAB entry in the PT_DYNAMIC segment.&lt;/p&gt;
&lt;p&gt;Dynamically linked binaries can be stripped but .dynsym and .dynstr cannot
be removed&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/"&gt;intezer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>#elf</category><category>#linux</category><category>#malware</category><category>#reverse</category><category>#security</category><guid>https://neetx.github.io/posts/ELF-symbols/</guid><pubDate>Sun, 17 Jan 2021 20:26:58 GMT</pubDate></item><item><title>ELF headers, sections and segments</title><link>https://neetx.github.io/posts/ELF-headers-sections-and-segments/</link><dc:creator>Neetx</dc:creator><description>&lt;div&gt;&lt;p&gt;ELF is a file format for executables file, Linux uses ELF files.
The name stands for Executable and Linkable Format&lt;/p&gt;
&lt;p&gt;Its components are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ELF Header&lt;/li&gt;
&lt;li&gt;Sections&lt;/li&gt;
&lt;li&gt;Segments&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;ELF Header&lt;/h3&gt;
&lt;p&gt;The ELF header is described by the type Elf32_Ehdr or Elf64_Ehdr, it 
information about the binary.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="cm"&gt;/* The ELF file header.  This appears at the start of every ELF file.  */&lt;/span&gt;
&lt;span class="cp"&gt;#define EI_NIDENT (16)&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;  &lt;span class="n"&gt;e_ident&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;EI_NIDENT&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  &lt;span class="cm"&gt;/* Magic number and other info    */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Half&lt;/span&gt;     &lt;span class="n"&gt;e_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="cm"&gt;/* Object file type                */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Half&lt;/span&gt;     &lt;span class="n"&gt;e_machine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="cm"&gt;/* Architecture                     */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;     &lt;span class="n"&gt;e_version&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="cm"&gt;/* Object file version              */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Addr&lt;/span&gt;     &lt;span class="n"&gt;e_entry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="cm"&gt;/* Entry point virtual address      */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Off&lt;/span&gt;      &lt;span class="n"&gt;e_phoff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="cm"&gt;/* Program header table file offset */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Off&lt;/span&gt;      &lt;span class="n"&gt;e_shoff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="cm"&gt;/* Section header table file offset */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;     &lt;span class="n"&gt;e_flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="cm"&gt;/* Processor-specific flags         */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Half&lt;/span&gt;     &lt;span class="n"&gt;e_ehsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* ELF header size in bytes         */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Half&lt;/span&gt;     &lt;span class="n"&gt;e_phentsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="cm"&gt;/* Program header table entry size  */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Half&lt;/span&gt;     &lt;span class="n"&gt;e_phnum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="cm"&gt;/* Program header table entry count */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Half&lt;/span&gt;     &lt;span class="n"&gt;e_shentsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="cm"&gt;/* Section header table entry size  */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Half&lt;/span&gt;     &lt;span class="n"&gt;e_shnum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="cm"&gt;/* Section header table entry count */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Half&lt;/span&gt;     &lt;span class="n"&gt;e_shstrndx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Section header string table index*/&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;Elf32_Ehdr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;   &lt;span class="n"&gt;e_ident&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;EI_NIDENT&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  &lt;span class="cm"&gt;/* Magic number and other info   */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Half&lt;/span&gt;      &lt;span class="n"&gt;e_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="cm"&gt;/* Object file type               */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Half&lt;/span&gt;      &lt;span class="n"&gt;e_machine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Architecture                     */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Word&lt;/span&gt;      &lt;span class="n"&gt;e_version&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Object file version              */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Addr&lt;/span&gt;      &lt;span class="n"&gt;e_entry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Entry point virtual address      */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Off&lt;/span&gt;       &lt;span class="n"&gt;e_phoff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Program header table file offset */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Off&lt;/span&gt;       &lt;span class="n"&gt;e_shoff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Section header table file offset */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Word&lt;/span&gt;      &lt;span class="n"&gt;e_flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Processor-specific flags         */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Half&lt;/span&gt;      &lt;span class="n"&gt;e_ehsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="cm"&gt;/* ELF header size in bytes         */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Half&lt;/span&gt;      &lt;span class="n"&gt;e_phentsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="cm"&gt;/* Program header table entry size  */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Half&lt;/span&gt;      &lt;span class="n"&gt;e_phnum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Program header table entry count */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Half&lt;/span&gt;      &lt;span class="n"&gt;e_shentsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="cm"&gt;/* Section header table entry size  */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Half&lt;/span&gt;      &lt;span class="n"&gt;e_shnum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="cm"&gt;/* Section header table entry count */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Half&lt;/span&gt;      &lt;span class="n"&gt;e_shstrndx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="cm"&gt;/* Section header string table index*/&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;Elf64_Ehdr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;e_ident[EI_NIDENT]&lt;/strong&gt; is a 16 bytes array that contains identification flags
about the file, these flags are used to interpret and decode the file
Flags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EI_MAG0-3    : ELF magic number&lt;/li&gt;
&lt;li&gt;EI_CLASS     : File class.&lt;/li&gt;
&lt;li&gt;EI_DATA      : Fileâs data encoding.&lt;/li&gt;
&lt;li&gt;EI_VERSION   : Fileâs version.&lt;/li&gt;
&lt;li&gt;EI_OSABI     : OS/ABI identification.&lt;/li&gt;
&lt;li&gt;EI_ABIVERSION: ABI version&lt;/li&gt;
&lt;li&gt;EI_PAD       : Start of padding bytes.&lt;/li&gt;
&lt;li&gt;EI_NIDENT    : Size of ei_ident.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Command to get elf header&lt;/p&gt;
&lt;pre class="code literal-block"&gt;readelf -h elf_name
&lt;/pre&gt;
&lt;hr&gt;
&lt;h3&gt;Sections&lt;/h3&gt;
&lt;p&gt;Sections contains all the information for linking (link-time and not at
runtime).
There is a Section Header Table, an array of structures Elf64_Shdr (and
Elf32_Shdr for i386 ABI), there is an array entry for each section.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="cm"&gt;/* Section header.  */&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Section name (string tbl index)      */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Section type                         */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="cm"&gt;/* Section flags                        */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Addr&lt;/span&gt;    &lt;span class="n"&gt;sh_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Section virtual addr at execution    */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Off&lt;/span&gt;     &lt;span class="n"&gt;sh_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="cm"&gt;/* Section file offset                  */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Section size in bytes                */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_link&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Link to another section              */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_info&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Additional section information       */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_addralign&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="cm"&gt;/* Section alignment                    */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_entsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="cm"&gt;/* Entry size if section holds table    */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;Elf32_Shdr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Section name (string tbl index)      */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Section type                         */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Xword&lt;/span&gt;   &lt;span class="n"&gt;sh_flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="cm"&gt;/* Section flags                        */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Addr&lt;/span&gt;    &lt;span class="n"&gt;sh_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Section virtual addr at execution    */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Off&lt;/span&gt;     &lt;span class="n"&gt;sh_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="cm"&gt;/* Section file offset                  */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Xword&lt;/span&gt;   &lt;span class="n"&gt;sh_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Section size in bytes                */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_link&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Link to another section              */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Word&lt;/span&gt;    &lt;span class="n"&gt;sh_info&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* Additional section information       */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Xword&lt;/span&gt;   &lt;span class="n"&gt;sh_addralign&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="cm"&gt;/* Section alignment                    */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Xword&lt;/span&gt;   &lt;span class="n"&gt;sh_entsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="cm"&gt;/* Entry size if section holds table    */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;Elf64_Shdr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Some sections:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.text   : code.&lt;/li&gt;
&lt;li&gt;.data   : initialised data.&lt;/li&gt;
&lt;li&gt;.rodata : initialised read-only data.&lt;/li&gt;
&lt;li&gt;.bss    : uninitialized data.&lt;/li&gt;
&lt;li&gt;.plt    : PLT (Procedure Linkage Table) (IAT equivalent).&lt;/li&gt;
&lt;li&gt;.got    : GOT entries dedicated to dynamically linked global variables.&lt;/li&gt;
&lt;li&gt;.got.plt: GOT entries dedicated to dynamically linked functions.&lt;/li&gt;
&lt;li&gt;.symtab : global symbol table.&lt;/li&gt;
&lt;li&gt;.dynamic: Holds all needed information for dynamic linking.&lt;/li&gt;
&lt;li&gt;.dynsym : symbol tables dedicated to dynamically linked symbols.&lt;/li&gt;
&lt;li&gt;.strtab : string table of .symtab section.&lt;/li&gt;
&lt;li&gt;.dynstr : string table of .dynsym section.&lt;/li&gt;
&lt;li&gt;.interp : RTLD embedded string.&lt;/li&gt;
&lt;li&gt;.rel.dyn: global variable relocation table.&lt;/li&gt;
&lt;li&gt;.rel.plt: function relocation table.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Command to get section headers&lt;/p&gt;
&lt;pre class="code literal-block"&gt;readelf -S elf_name
&lt;/pre&gt;
&lt;hr&gt;
&lt;h3&gt;Segments&lt;/h3&gt;
&lt;p&gt;Also called Programm Headers, segments split the binary into chunks, they
aren't useful at linktime.
There is a Program Header Table, an array of Elf64_Phdr (or Elf32_Phdr for
i386 ABI), there is an array entry for each segment.&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="cm"&gt;/* Program segment header.  */&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;        &lt;span class="n"&gt;p_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="cm"&gt;/* Segment type             */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Off&lt;/span&gt;         &lt;span class="n"&gt;p_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="cm"&gt;/* Segment file offset      */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Addr&lt;/span&gt;        &lt;span class="n"&gt;p_vaddr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="cm"&gt;/* Segment virtual address  */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Addr&lt;/span&gt;        &lt;span class="n"&gt;p_paddr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="cm"&gt;/* Segment physical address */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;        &lt;span class="n"&gt;p_filesz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="cm"&gt;/* Segment size in file     */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;        &lt;span class="n"&gt;p_memsz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="cm"&gt;/* Segment size in memory   */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;        &lt;span class="n"&gt;p_flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="cm"&gt;/* Segment flags            */&lt;/span&gt;
  &lt;span class="n"&gt;Elf32_Word&lt;/span&gt;        &lt;span class="n"&gt;p_align&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="cm"&gt;/* Segment alignment        */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;Elf32_Phdr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Word&lt;/span&gt;        &lt;span class="n"&gt;p_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="cm"&gt;/* Segment type             */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Word&lt;/span&gt;        &lt;span class="n"&gt;p_flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="cm"&gt;/* Segment flags            */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Off&lt;/span&gt;         &lt;span class="n"&gt;p_offset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="cm"&gt;/* Segment file offset      */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Addr&lt;/span&gt;        &lt;span class="n"&gt;p_vaddr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="cm"&gt;/* Segment virtual address  */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Addr&lt;/span&gt;        &lt;span class="n"&gt;p_paddr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="cm"&gt;/* Segment physical address */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Xword&lt;/span&gt;       &lt;span class="n"&gt;p_filesz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="cm"&gt;/* Segment size in file     */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Xword&lt;/span&gt;       &lt;span class="n"&gt;p_memsz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="cm"&gt;/* Segment size in memory   */&lt;/span&gt;
  &lt;span class="n"&gt;Elf64_Xword&lt;/span&gt;       &lt;span class="n"&gt;p_align&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="cm"&gt;/* Segment alignment        */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;Elf64_Phdr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;p_type&lt;/strong&gt; common values are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PT_NULL   : unassigned segment (first entry of Program Header Table)&lt;/li&gt;
&lt;li&gt;PT_LOAD   : Loadable segment&lt;/li&gt;
&lt;li&gt;PT_INTERP : Segment holding .interp section&lt;/li&gt;
&lt;li&gt;PT_TLS    : Thread Local Storage segment (Common in static binaries)&lt;/li&gt;
&lt;li&gt;PT_DYNAMIC: Holding .dynamic section&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;important&lt;/strong&gt;: Only PT_LOAD segments will be loaded in memory, the others
are mapped in the memory range of one of the loaded segments.&lt;/p&gt;
&lt;p&gt;Command to get segment/program header:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;readelf -I elf_name
&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;So sections contain information about linking and Program Headers split
binary into segments.&lt;/p&gt;
&lt;p&gt;Segments have offsets and virtual addresses that must be congruent modulo
the sytem page size, and p_align must be a multiple of the system page
size.&lt;/p&gt;
&lt;p&gt;With this alignment the segment mapping can't overlap in a single memory
page. A problem for the overlap are different access attributes, these 
cannot be forced if two segments are mapped in the same memory page.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;References:
&lt;a href="https://www.intezer.com/blog/research/executable-linkable-format-101-part1-sections-segments/"&gt;intezer&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;</description><category>#elf</category><category>#linux</category><category>#malware</category><category>#reverse</category><category>#security</category><guid>https://neetx.github.io/posts/ELF-headers-sections-and-segments/</guid><pubDate>Sat, 16 Jan 2021 15:29:26 GMT</pubDate></item></channel></rss>